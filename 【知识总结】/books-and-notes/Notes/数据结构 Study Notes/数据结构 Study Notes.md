# 数据结构 [^ 数据结构 reference] Study Notes [^ history version]

@(Notes)[数据结构, Notes]

> VICTORY LOVES PREPARATION.

[^ 数据结构 reference]: [百度百科][4]

[^ history version]: 
> 版本信息：
> 2017年2月22日 下午1:26:53

[TOC]

***

## 、思维导图
- **`SUMMARY:`**

<br>
## 一、简介 [^ profile reference]
[^ profile reference]: [CSDN][3]

### 1.1 什么是数据结构
- **`SUMMARY:`数据结构是计算机存储、组织数据的方式，学习数据结构是修炼内力，不想学好基础的程序员不是好程序员。**
- 数据结构是计算机存储、组织数据的方式；
- 如果说`Java`是自动档轿车，`C`就是手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从`A`开到`B`，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。如果你对这两件事都不感兴趣也就罢了，数据结构懂得用就好。但若你此生在编程领域还有点更高的追求，数据结构是绕不开的课题；
`Java`替你做了太多事情，那么多动不动还支持范型的容器类，加上垃圾收集，会让你觉得编程很容易。但你有没有想过，那些容器类是怎么来的，以及它存在的意义是什么？最粗浅的，比如`ArrayList`这个类，你想过它的存在是多么大的福利吗――一个可以随机访问、自动增加容量的数组，这种东西`C`是没有的，要自己实现。但是，具体怎么实现呢？如果你对这种问题感兴趣，那数据结构是一定要看的。甚至，面向对象编程范式本身，就是个数据结构问题：怎么才能把数据和操作数据的方法封装到一起，来造出`class/prototype`这种东西？
此外，很重要的一点是，数据结构也是通向各种实用算法的基石，所以**学习数据结构都是提升内力的事情；**
- **不想学好基础的程序员不是好的程序员；**
- [老罗的Android之旅；][1]
- [专访雷果国：从1.5K到18K 一个程序员的5年成长之路。][2]
### 1.2 基本概念和术语
### 1.3 抽象数据类型的表现和实现
### 1.4 算法和算法分析

<br>
## 二、具体内容
### 2.1 线性表
### 2.2 栈和队列
### 2.3 串
### 2.4 数组和广义表
### 2.5 树
### 2.6 图
### 2.7 动态存储管理
### 2.8 查找
#### 2.8.1 静态查找表
#### 2.8.2 动态查找表
#### 2.8.3 哈希表 [^ Hash Table Reference]
[^ Hash Table Reference]: [博客园][5]

##### 2.8.3.1 什么是哈希表
##### 2.8.3.2 哈希函数的构造方法
##### 2.8.3.4 处理冲突的方法
##### 2.8.3.5 哈希表的查找及其分析
### 2.9 排序
### 2.10 文件

<br>
## 三、注意事项

<br>
## 三、逻辑结构
### 2.3 集合
- **`SUMMARY:` 大致可分为三大类：`Set`、`List`和`Map`，具体每个内部用两个标准进行分类，数组或者链表分类标准以及线程是否安全。**
- 具体实现原理有待深入了解和总结。
- ![][20]
- ![][21]
#### 2.3.1 基本概念
#### 2.3.2 Collection接口
- 最基本的集合接口，代表一组`Object`。

##### 2.3.2.1 Set
- 无序的，不允许有重复的元素的集合。

###### 2.3.2.1.1 HashSet
- `SUMMARY:` `HashSet`实现`Set`接口，由哈希表（实际上是一个`HashMap`实例）支持。它不保证`set`的迭代顺序，**特别是它不保证该顺序恒久不变**。此类允许使用`null`元素。
- `HashSet`实现`Set`接口，由哈希表（实际上是一个`HashMap`实例）支持。它不保证`set`的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用`null`元素。
- `Object`类中的`hashCode()`的方法是所有类都会继承的方法，这个方法会算出一个`Hash`码值返回，`HashSet`会用`Hash`码值去和数组长度取模，对象的模值（这个模值就是对象要存放在数组中的位置，和数组的下标相同）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会再找位置添加进去，相同则不允许添加；
- 如果数组中的元素和要加入的对象的`hashCode()`返回了相同的`Hash`码值，才会用`equals()`方法来判断两个对象的内容是否相同；
- `HashSet`的实现：
	- 对于`HashSet`而言，它是基于`HashMap`实现的，`HashSet`底层使用`HashMap`来保存所有元素，因此`HashSet`的实现比较简单，相关`HashSet`的操作，基本上都是直接调用底层`HashMap`的相关方法来完成。

	> *注意*
	> - 要存入`HashSet`的集合对象中的自定义类必须覆盖`hashCode()`、`equals()`两个方法，才能保证集合中元素不重复。

###### 2.3.2.1.2 TreeSet
- 可排序的`Set`；
- `SortedSet`接口是`Set`的子接口，`TreeSet`是`SortedSet`接口的实现类，他可以对集合中的元素进行排序；
- 将自定义类的对象存放在`TreeSet`中，这个类需要实现了`Comparable`接口，`TreeSet`可以自动过滤掉重复元素所以不在需要重载`hashCode()`方法，`TreeSet`会根据比较规则判断元素内容是否相同，不同则会存入，`TreeSet`会在元素存入时就进行排序。

###### 2.3.2.1.3 LinkedHashSet
##### 2.3.2.2 List
- 有序的、可重复的单元素集合。

###### 2.3.2.2.1 ArrayList
- `SUMMARY:`实质上是一个自动增长的数组、查询效率比较高，增删的效率比较低、非线程安全。
- **实质上是一个自动增长的数组**；
- **查询效率比较高，增删的效率比较低**，适用于查询比较频繁，增删动作较少的元素管理的集合；
- 加载大批量的数据时，先进行手动扩容（就是调用`ensureCapacity(int minCapacity)`方法），这样可以提高效率；
- `ArrayList`是`List`接口的可变数组的实现。实现了所有可选列表操作，并允许包括`null`在内的所有元素。除了实现`List`接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小；
- 每个`ArrayList`实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向`ArrayList`中不断添加元 素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造`ArrayList`时指定其容量。在添加大量元素前，应用程序也可以使用`ensureCapacity`操作来增加`ArrayList`实例的容量，这可以减少递增式再分配的数量；
- 注意，此实现不是同步的。如果多个线程同时访问一个`ArrayList`实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。

###### 2.3.2.2.2 LinkedList
- **底层是用双向循环链表来实现的**；
- **查询效率低，但是增删效率很高**，适用于增删动作的比较频繁，查询次数较少的元素管理的集合。

###### 2.3.2.2.3 ArrayList

#### 2.3.3 Map接口
- 提供`key`到`value`的映射。

##### 2.3.3.1 HashMap
- `SUMMARY:`实质上是基于哈希表的`Map`接口的实现（链表散列）、非线程安全。
- 基于哈希表的`Map`接口的实现，此实现提供所有可选的映射操作，并允许使用`null`值和`null`键；
- 非线程安全，不支持并发控制，允许空的键值对。
- `HashMap`是基于哈希表的`Map`接口的非同步实现。此实现提供所有可选的映射操作，并允许使用`null`值和`null`键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
- `HashMap`的数据结构
	- 在`java`编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，`HashMap`也不例外。`HashMap`实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
- `HashMap`底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个`HashMap`的时候，就会初始化一个数组。

##### 2.3.3.2 HashTable
- 同`HashMap`，一般不使用；
- 是线程安全，支持并发控制，不允许有空的键值对。

##### 2.3.3.3 TreeMap
##### 2.3.3.4 LinkedHashMap
- `SUMMARY:` `LinkedHashMap`是`Map`接口的哈希表和（双向）链接列表实现，具有可预知的迭代顺序。
- 概述
	- `LinkedHashMap`是`Map`接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用`null`值和`null`键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
	- `LinkedHashMap`实现与`HashMap`的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。
	- 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。
- 实现
	- 对于`LinkedHashMap`而言，它继承与`HashMap`、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类`HashMap`相似，它通过重写父类相关的方法，来实现自己的链接列表特性。

#### 2.3.4 ArrayList、Vector和LinkedList的存储性能
- `ArrayList`和`Vector`都是使用**数组方式**存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素（**插在数组的中间部分**）涉及数组元素移动等内存操作，所以**索引数据快而插入数据慢**，`Vector`由于使用了`synchronized`方法（**线程安全**），通常**性能**上较`ArrayList`差，而`LinkedList`使用**双向链表**实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以**插入速度较快**，`LinkedList`也是**线程不安全**的；
- `LinkedList`提供了一些方法，使得`LinkedList`可以**被当作堆栈和队列来使用**。

	``` java
	new LinkedList<String>().addFirst("First");
	new LinkedList<String>().addLast("Last");
	```


> *注意*
> - 遍历`iterator`增强`for`循环内部实质上调用了`interator`，除了简单的遍历，不建议使用增强`for`循环。
> - `Map`中`key`一般是`8`种基本类型的封装类或者是`String`类，拿自己自定义的类作为`Key`没有意义；
> - `Map`中`key`不可重复，`value`可以重复。


[1]: http://www.csdn.net/article/2014-08-15/2821226#0-tsina-1-88992-397232819ff9a47a7b7e80a40613cfe1
[2]: http://www.csdn.net/article/2013-05-13/2815252
[3]: http://blog.csdn.net/iaiti/article/details/39268173
[4]: http://baike.baidu.com/link?url=iIfEI6tUhAb4M5_OlM8v-XX6HdYsTUMU4iXw3lz7g-pfkNkehlPBk5uVDsYB8U-drkZ73HH8zJwUm3_w4VE-hFguieGBtterl8BmK6QCZr8YRKKhGlBPk10O6N884PRK#7
[5]: http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html
[20]: http://i1.piimg.com/567571/222535dbb246dfb3.png
[21]: http://p1.bpimg.com/567571/ea3cd59d77e92390.jpg