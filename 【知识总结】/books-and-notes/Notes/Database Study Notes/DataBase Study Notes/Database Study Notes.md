# Database Study Notes [^ history version]

@(Notes)[数据库, SQL, Notes]

> VICTORY LOVES PREPARATION.

[^ history version]: 
> 版本信息：
> 2017年04月02日 下午08:23:03
> 2017年03月22日 上午11:49:05
> 2017年03月17日 下午02:33:39
> 2017年03月12日 下午06:56:02
> 2016年12月29日 16:20 

[TOC]

***
## 、思维导图

<br>
## 一、事务
### 1.1 含义
- **`SUMMARY：`操作数据库的程序执行单元。**
- 一般是指要做的或者所做的事情；
- 计算机术语上指访问并可能更新数据库中数据项的一个程序执行单元。

### 1.2 特性（ACID）[^ CSDN Reference]
[^ CSDN Reference]: [CSDN][8]

#### 1.2.1 原子性（Atomicity）
- **`SUMMARY：`要么不做，要做就做完（偏向事务的开始和过程）。**
- 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。

#### 1.2.2 一致性（Consistency）
- **`SUMMARY：`数据库必须相对于事务具有数据完整性（偏向事务（出现异常时候）的结果），也就是说事务中包含的一系列操作要么同时成功，要么同时失败。**
- 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态；
- 因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态；
- 如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。 

#### 1.2.3 隔离性（Isolation）
- **`SUMMARY：`事务在执行过程中不能受到其他干扰（偏向事务的过程，对事务进行保护）。**
- 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

#### 1.2.4 持久性（Durability）[^ transaction roll forward reference]
[^ transaction roll forward reference]: [CSDN][10]

- **`SUMMARY：`事务对数据库的改变是不能受到其他情况影响的（偏向事务（任何情况下）的结果），也就是说一旦事务提交了额，那么其对数据库造成的影响将是持久的，如果提交了事务，即便发生灾难，也会完成持久化操作（如果事务提交之后没有成功持久化到数据库，那么解决灾难之后，可以通过事务的前滚完成事务，保证事务的持久性）。**
- 也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响；
- 事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。

###1.3 数据并发操作存在的问题 [^ problems when operate database concurrently]
[^ problems when operate database concurrently]: [ImportNew][11]

#### 1.3.1  丢失更新 [^ lost update reference]
[^ lost update reference]: [CSDN][3]

- **`SUMMARY：` `A`事务撤销时，把已经提交的`B`事务的更新数据覆盖了或者`A`事务覆盖`B`事务已经提交的数据，造成`B`事务所做操作丢失。**

##### 1.3.1.1 第一类丢失更新（`First` `Lost` `Update`）
- 一般是指同时发生了两个事务，不仅丢了第一个事务的数据还丢了第二个事务的数据。

##### 1.3.1.2 第二类丢失更新（`Second` `Lost` `Update`）
- 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。

	> *注意*
	> - 解决方法
	>  - 对行加锁，只允许并发一个更新事务。

#### 1.3.2  脏读
- **`SUMMARY：`脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。**
- 脏读是指在一个事务处理过程里读取了**另一个未提交的事务中的数据**。
- *`EG.`脏读实例：*
	- 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户`A`向用户`B`转账`100`元，对应`SQL`如下：

		``` xml
		update account set money = money + 100 where name=’B’;  (此时A通知B)
		update account set money = money - 100 where name=’A’;
		```
	
	- 当只执行第一条`SQL`时，`A`通知`B`查看账户，`B`发现确实钱已到账（此时即发生了脏读），而之后无论第二条`SQL`是否执行，只要该事务不提交，则所有操作都将回滚，那么当`B`以后再次查看账户时就会发现钱其实并没有转。

#### 1.3.3 不可重复读
- **`SUMMARY：`对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值。**
- 不可重复读是指在对于数据库中的某个数据，**一个事务范围**内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。
- *`EG.`不可重复读实例：*
	- 事务`T1`在读取某一数据，而事务`T2`立马修改了这个数据并且提交事务给数据库，事务`T1`再次读取该数据就得到了不同的结果，发送了不可重复读。

	> *注意*
	> - 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，*`eg.`实例：*
	>  - 对于同一个数据`A`和`B`依次查询就可能不同。

#### 1.3.4 幻读（虚读）
- **`SUMMARY：`参考下面。**
- **一个事务范围**，幻读是事务非独立执行时发生的一种现象。例如事务`T1`对一个表中所有的行的某个数据项做了从`“1”`修改为`“2”`的操作，这时事务`T2`又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务`T1`的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务`T2`中添加的，就好像产生幻觉一样，这就是发生了幻读。

	> *注意*
	> - 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是**不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）**。
	> - 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

### 1.4 隔离级别 [^ transaction isolation rank]
[^ transaction isolation rank]: [博客园][2]

- **`SUMMARY：`当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，共有四种隔离界别。**
- *`IMG.`数据库的隔离级别：* <br><br>![][4]
<br>

#### 1.4.1 Serializable （串行化）
- 可避免脏读、不可重复读、幻读的发生。

#### 1.4.2 Repeatable read （可重复读）
- 可避免脏读、不可重复读的发生。

#### 1.4.3 Read committed （读已提交）
- 可避免脏读的发生。

#### 1.4.4 Read uncommitted （读未提交）
- 最低级别，任何情况都无法保证。

> *注意*
> - 大多数的数据库系统的默认事务隔离级别都是：`Read` `committed`，而`MySQL`的默认事务隔离级别是：`Repeatable Read。`
> - 事务的级别越高，效率越低。因为级别越高加的锁越多越复杂
> - 一般数据库引擎为read-committed（折中的办法，即高层度地解决了事务并发问题，又提高了查询效率），然后通过代码解决非重复读（幻读的解决方式基本上只有设置隔离级别为serializable，即级别8）


### 1.5 传播行为 [^ Transaction Propagation Reference]
[^ Transaction Propagation Reference]: [Spring.io][5]

- **`SUMMARY：`如果在`Service`方法中，除了调用了`DAO`层的方法之外，还调用了本类的其他的`Service`方法，那么在调用其他的`Service`方法的时候，为了确保所调用的方法和调用方法的方法处在一个事务内。**
- *`EG.`实例：*[^ Transaction Propagation Instance Reference]
	- 当我们调用`Service`层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。如果你在你的`Service`层的这个方法中，除了调用了`Dao`层的方法之外，还调用了本类的其他的`Service`方法，那么在调用其他的`Service`方法的时候，为了确保所调用的方法和调用方法的方法处在一个事务内。是解决这个问题的，“事务是会传播的”在`Spring`中有针对传播特性的多种配置我们大多数情况下只用其中的一种：`PROPGATION_REQUIRED`：这个配置项的意思是说当我调用`service`层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的`aop`的配置),那么在调用这个`service`层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由`Spring`来帮助我们完成的。以前没有`Spring`帮助我们完成事务的时候我们必须自己手动的控制事务，例如当我们项目中仅仅使用`hibernate`，而没有集成进`spring`的时候，我们在一个`service`层中调用其他的业务逻辑方法，为了保证事物必须也要把当前的`hibernate` `session`传递到下一个方法中，或者采用`ThreadLocal`的方法，将`session`传递给下一个方法，其实都是一个目的。现在这个工作由`spring`来帮助我们完成，就可以让我们更加的专注于我们的业务逻辑。而不用去关心事务的问题。默认情况下当发生`RuntimeException`的情况下，事务才会回滚，所以要注意一下如果你在程序发生错误的情况下，有自己的异常处理机制定义自己的`Exception`，必须从`RuntimeException`类继承，这样事务才会回滚！

#### 1.5.1 REQUIRED
- **`SUMMARY：`支持当前事务，如果没有事务，就建一个新的，这是最常见的。**
- 支持当前事务，如果没有事务，就建一个新的，这是最常见的。
#### 1.5.2 SUPPORTS
- 支持当前事务，如果当前没有事务，就以非事务方式执行。
#### 1.5.3 MANDATORY
- 支持当前事务，如果当前没有事务，就抛出异常。
#### 1.5.4 REQUIRESNEW
- 新建事务，如果当前存在事务，把当前事务挂起。
#### 1.5.5 NOTSUPPORTED
- 以非事务方式执行操作，如果当前存在事务，就把事务挂起。
#### 1.5.6 NEVER
- 以非事务方式执行，如果当前存在事务，则抛出异常。
#### 1.5.7 NESTED
- 新建事务，如果当前存在事务，把当前事务挂起。与`RequireNew`的区别是与父事务相关，且有一个`savepoint`。

[^ Transaction Propagation Instance Reference]: [百度知道][6]

> *注意*
> - 上面`7`中行为是`Spring`中的事务传播行为；
> - 详细介绍有待深入研究、归纳整理。

### 1.6 前滚和回滚 [^ transaction roll forward reference]
<br>
## 二、锁 [^ ITpub Reference]
[^ ITpub Reference]: [ITpub][1]
### 2.1 悲观锁
- **`SUMMARY：`顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会`block`直到它拿到锁。**
- （`Pessimistic Lock`）顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会`block`直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如**行锁**，**表锁**等，**读锁**，**写锁**等，都是在做操作之前先上锁。

### 2.2 乐观锁
- **`SUMMARY：` 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。**
- （`Optimistic Lock`） 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于`write_condition`机制的其实都是提供的乐观锁；
- 乐观锁，大多是基于数据版本（`Version`）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个`version`字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

### 2.3 共享锁
- **`SUMMARY：`加了共享锁的数据对象可以被其他事务读取，但不能修改。**
- 加了共享锁的数据对象可以被其他事务读取，但不能修改。

### 2.4 排他锁
- **`SUMMARY：`当数据对象被加上排它锁时，其他的事务不能对它读取和修改。**
- 当数据对象被加上排它锁时，其他的事务不能对它读取和修改。

<br>
## 三、连接池 [^ Database Pool Reference]
[^ Database Pool Reference]: [百度百科][7]

- **`SUMMARY：`数据库连接池负责数据库连接地管理，包括分配和释放等操作，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个，明显提高对数据库操作的性能。**
- 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；
- 释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。
- 这项技术能明显提高对数据库操作的性能。

### 3.1 为什么要用连接池
- **`SUMMARY：`降低操作数据的时间，提高应用程序的性能。**
- 数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。
- 对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。
- 数据库连接池正是针对这个问题提出来的。
- 由于创建连接和释放连接都有很大的开销（**尤其是数据库服务器不在本地时，每次建立连接都需要进行`TCP`的三次握手，释放连接需要进行`TCP`四次握手**，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在`Java`开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于`Java`的开源数据库连接池主要有：`C3P0`、`Proxool`、`DBCP`、`BoneCP`、`Druid`等。

### 3.2 影响因素
- **`SUMMARY：`最小连接数、最大连接数和它们之间的差距。**
- 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数制约。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。
- 连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。
- *`FOLLOW.`数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：*

#### 3.2.1 最小连接数
- **`SUMMARY：`连接词最小、一直保持的数据库连接数。**
- 是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。

#### 3.2.2 最大连接数
- **`SUMMARY：`连接池能够拥有的最大数据库连接数。**
- 是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。

#### 3.2.3 最大连接数和最小连接数差距
- **`SUMMARY：`最大数据库连接数和最小数据库连接数之间的差值。**
- 最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。

### 3.3 原理
- **`SUMMARY：`使用数据库连接的时候，不是新生成一个连接，而是从连接池中获取一个连接；使用完毕后直接放回连接池中，而不是关闭连接。把连接交给连接池进行管理。**
- **系统初始化**的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象；
- **使用完毕后**，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用；
- 而连接的建立、断开都由连接池自身来管理；
- 通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等；
- 通过其自身的管理机制来监视数据库连接的数量、使用情况等。

### 3.4 类别
- **`SUMMARY：`常用的有`C3P0`、`DBCP`和`Druid`等连接池。**
- *`FOLLOW.`在`Java`中开源的数据库连接池有以下几种：*
#### 3.4.1 C3P0
- 是一个开放源代码的`JDBC`连接池，包括了实现`jdbc3`和`jdbc2`扩展规范说明的`Connection`和`Statement`池的`DataSources`对象。

#### 3.4.2 Proxool
- 是一个`Java` `SQL` `Driver`驱动程序，提供了对选择的其它类型的驱动程序的连接池封装。
- 可以非常简单的移植到现存的代码中，完全可配置，快速、成熟、健壮。可以透明地为现存的JDBC驱动程序增加连接池功能。

#### 3.4.3 DBCP
- `Jakarta` `DBCP`是一个依赖`Jakartacommons-pool`对象池机制的数据库连接池。
- `DBCP`可以直接的在应用程序中使用。

#### 3.4.5 DDConnectionBroker
- 是一个简单、轻量级的数据库连接池。

#### 3.4.6 DBPool
- 是一个高效、易配置的数据库连接池。它除了支持连接池应有的功能之外，还包括了一个对象池，使用户能够开发一个满足自己需求的数据库连接池。

#### 3.4.7 XAPool
- 是一个`XA`数据库连接池。它实现了`javax.sql.XADataSource`并提供了连接池工具。

#### 3.4.8 Primrose
- 是一个`Java`开发的数据库连接池。
- 当前支持的容器包括`Tomcat4&5`、`Resin3`与`JBoss3`。
- 它同样也有一个独立的版本，可以在应用程序中使用而不必运行在容器中。
- `Primrose`通过一个`WEB`接口来控制`SQL`处理的追踪、配置，以及动态池管理。在重负荷的情况下可进行连接请求队列处理。

#### 3.4.9 SmartPool
- 是一个连接池组件，它模仿应用服务器对象池的特性。
- `SmartPool`能够解决一些临界问题如连接泄漏（`connection` `leaks`）、连接阻塞、打开的`JDBC`对象（如`Statements`、`PreparedStatements`）等。
- *`FOLLOW.` `SmartPool`的特性包括：*
	- 支持多个`pool`；
	- 自动关闭相关联的`JDBC`对象；
	- 在所设定`time-outs`之后察觉连接泄漏；
	- 追踪连接使用情况；
	- 强制启用最近最少用到的连接；
	- 把`SmartPool`“包装”成现存的一个`pool`。

#### 3.4.10 MiniConnectionPoolManager
- 是一个轻量级`JDBC`数据库连接池。
- 它只需要`Java1.5`（或更高）并且没有依赖第三方包。

#### 3.4.11 BoneCP
- 是一个快速、开源的数据库连接池。
- 帮用户管理数据连接，让应用程序能更快速地访问数据库。比`C3P0`/`DBCP`连接池速度快`25`倍。

#### 3.4.12 Druid [^ Druid Reference]
[^ Druid Reference]: [开源中国][9]

- `Druid`不仅是一个数据库连接池，还包含一个`ProxyDriver`、一系列内置的`JDBC`组件库、一个`SQL Parser`。
支持所有`JDBC`兼容的数据库，包括`Oracle`、`MySql`、`Derby`、`Postgresql`、`SQL` `Server`、`H2`等。
*`FOLLOW.` `Druid`针对`Oracle`和`MySql`做了特别优化，比如：*
	- `Oracle`的`PS` `Cache`内存占用优化；
	- `MySql`的`ping`检测优化。
- `Druid`提供了`MySql`、`Oracle`、`Postgresql`、`SQL-92`的`SQL`的完整支持，这是一个手写的高性能`SQL` `Parser`，支持`Visitor`模式，使得分析`SQL`的抽象语法树很方便。
- 简单`SQL`语句用时`10`微秒以内，复杂`SQL`用时`30`微秒。
- 通过`Druid`提供的`SQL` `Parser`可以在`JDBC`层拦截`SQL`做相应处理，比如说分库分表、审计等。`Druid`防御`SQL`注入攻击的`WallFilter`，就是通过`Druid`的`SQL` `Parser`分析语义实现的。
- **可以监控数据库访问性能：**
	- `Druid`内置提供了一个功能强大的`StatFilter`插件，能够详细统计`SQL`的执行性能，这对于线上分析数据库访问性能有帮助。 
- **替换`DBCP`和`C3P0`：**
	- `Druid`提供了一个高效、功能强大、可扩展性好的数据库连接池。
- **数据库密码加密：**
	- 直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。`DruidDruiver`和`DruidDataSource`都支持`PasswordCallback`。

## 四、JDBC操作数据库的步骤
- **`SUMMARY：`六大步：加载驱动、创建连接、创建语句、执行语句、处理结果和关闭连接。**
### 4.1 加载驱动
- *`EG.`实例代码：*

	``` java
	Class.forName(driver);
	```

### 4.2 创建连接
- *`EG.`实例代码：*

	``` java
	Connection conn = DriverManager.getConnection(url, username, password)
	```

### 4.3 创建语句
- *`EG.`实例代码：*

	``` java
	Statement stmt = conn.createStatement()
	```

### 4.4 执行语句
- *`EG.`实例代码：*

	``` java
	ResultSet rs = stmt.executeQuery(sql)
	```

### 4.5 处理结果
- *`EG.`实例代码：*
	
	``` java
	while (rs.next()) {
		LOG.info(rs.getString("name"));
	}
	```

### 4.6 关闭资源
- *`EG.`实例代码：*

	``` java
	// 如果使用ARM语句，则不需要手动关闭资源
	rs.close();
	stmt.close();
	conn.close()
	```


<br>
## 五、存储过程 [^ Stored Procedure Reference]
[^ Stored Procedure Reference]: [博客园][12]

- **存储过程（`Stored Procedure`）是数据库中一组为了完成特定功能的`SQL`语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它**。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。

<br>
## 六、其他
- `SELECT LAST_INSERT_ID()`
	- 自动返回最后一个`INSERT`或`UPDATE`查询中`AUTO_INCREMENT`列设置的第一个表发生的值。
- 事务的并发处理可以参照`Hibernate Study Notes.docx`。

[1]: http://blog.itpub.net/11627468/viewspace-1788399/
[2]: http://www.cnblogs.com/fjdingsd/p/5273008.html
[3]: http://blog.csdn.net/mageshuai/article/details/4544188
[4]: http://p1.bqimg.com/567571/b4e7c6dffb57d67a.jpg
[5]: http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#tx-propagation
[6]: https://zhidao.baidu.com/question/303828692492970324.html
[7]: http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0?fr=aladdin
[8]: http://blog.csdn.net/xiaoyu714543065/article/details/8211265
[9]: http://www.oschina.net/p/druid/
[10]: http://blog.csdn.net/haiross/article/details/17003543
[11]: http://www.importnew.com/22083.html
[12]: http://www.cnblogs.com/chenpi/p/5136483.html